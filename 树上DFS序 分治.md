# 树上$DFS$序 分治

[TOC]

##简介

树上$DFS$序分治是一种比较**通用**的树上统计方法。思想是利用$DFS$序的**局部单调**性；由于只是【局部单调】，不得不舍弃一部分冲突的**继承信息**；而用**分治**的方法，可以将局部单调的元素 **有序组织**起来，使得复杂度变成：*单调部分* 转移时间$\times \log n$ 。

接下来我会先讲`框架`细节，然后举几个`例题`，并简易描述思路。读者可以试着自己将框架套到例子上。

---

## 框架

* 给一个有根树$G$， 设$G$ 的先序遍历数组为$dfn[\ ]$ ，则$G$上的任意一颗对应$dfn[\ ]$上的一段连续区间。
* 对于任意一颗非根子树，它所表示的区间$[L,R]$和其父亲节点说表示的区间$[L_{fa},R_{fa}]$有关系$L_{fa}<L, R\le R_{fa}$ 。
  * 换句话说，随着每一颗子树转移到它的父亲，子树表示区间的左端点单调下降，又端点单调不下降。
* 如果我们可以在$dfn[\ ]$上，将答案快速从$dfn[L,R]$转移到$dfn[L,R+1]$或$dfn[L-1,R]$的话，就可以将子树$x$的所有父子树答案依次计算出来。
* 考虑剩下没有计算出答案的子树，他们的子树区间和$x$子树的关系；这些子树区间$[L,R]$，只可能满足：$L\le R<x$ 或者 $x<L\le R$ 。
* 于是剩下的区间被自然地分成了两个不相交的集合。如果我们将$x$取值$dfn[\ ]$中点，问题规模就可以每次折半。

于是分治求解。

`pseudocode`

```python
function divide (L R)
	node x = dfn[(L+R)/2]
	while x!=root and L[x]<L and R[x]<R
		calc(L[x],R[x])
		x = x.fa;
	divide(L, (L+R)/2)
    divide((L+R)/2+1, R)
```

---

## 例题

### Sample 1

> #### 题意
>
> ​	给一颗有根树，每一个节点上有点权和颜色两种属性。求每颗子树中点权和最大的颜色以及这种颜色的点权和。同色输出编号较小的颜色。
>
> #### 数据规模
>
> 点数色数同级。关于点数规模$NlogN$ 复杂度可以接受。

维护一个数组，$c[x]$表示当前区间内，颜色为$x$的权值和。

自然，我们可以在拓展区间的时候更新这个数组，并且维护权值最大的颜色。

> P.S. 这个题还可以用虚树做。只需要把一个区间的最大颜色问题转换为一种颜色会在哪儿最大。甚至比分治还要优美。

### Sample 2

**NOIP 2015 运输计划 加强版**

在原题基础上，需要求每一条边被改造的答案。



一条$x$节点到它父亲的边，权值改变，被影响的路径一定只有一个端点在以$x$为根的子树当中。

维护被影响的节点与不被影响的节点两个集合，与集合中路径权值最大值。拓展区间的时候可以$logN$地更新集合。

总复杂度$Nlog^2N$

---

